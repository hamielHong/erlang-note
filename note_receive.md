receive 选择性接收
===

基本函数receive用来从进程邮箱里提取消息，但它所做的不仅仅是简单的模式匹配。

它还会把未匹配的消息加入队列供以后处理，并管理超时。

下面这个语句：

``` erlang
receive
    Pattern1 [when Guard1] ->
        Expressions1;
    Pattern2 [when Guard2] ->
        Expressions2;
    ...
after
    Time ->
        ExpressionsTimeout
end
```

它的工作方式如下。

1. 进入receive语句时会启动一个定时器（但只有当表达式包含after部分时才会如此）。

2. 取出邮箱里的第一个消息，尝试将它与Pattern1、Pattern2等模式匹配。如果匹配成功，系统就会从邮箱中移除这个消息，并执行模式后面的表达式。

3. 如果receive语句里的所有模式都不匹配邮箱的第一个消息，系统就会从邮箱中移除这个消息并把它放入一个“保存队列”，然后继续尝试邮箱里的第二个消息。这一过程会不断重复，直到发现匹配的消息或者邮箱里的所有消息都被检查过了为止。

4. 如果邮箱里的所有消息都不匹配，进程就会被挂起并重新调度，直到新的消息进入邮箱才会继续执行。新消息到达后，保存队列里的消息不会重新匹配，只有新消息才会进行匹配。

5. 一旦某个消息匹配成功，保存队列里的所有消息就会按照到达进程的顺序重新进入邮箱。如果设置了定时器，就会清除它。

6. 如果定时器在我们等待消息时到期了，系统就会执行表达式ExpressionsTimeout，并把所有保存的消息按照它们到达进程的顺序重新放回邮箱。

由此我们会发现选择性接收的一个弊端，即无用消息的堆积。

如果在模式匹配中不对无用消息进行匹配，无用消息将会进入保存队列堆积，最后要匹配到有用的消息会花费更长的时间，并占用大量内存空间。

解决方法
---

直接在匹配时对无用消息进行匹配，即在所有模式最后加上

> _ -> Expressions

这样可以保证所有的消息都会在匹配阶段被处理，不会堆积。