关于性能优化
===

++ 运算符
---

左侧列表的长度决定 ++ 运算符的耗时,新内容（通常较短）应该尽量从左侧加入列表

++ 运算符是 lists:append/2 的一个别名，这个问题对该函数同样适用

-- 运算符
---

-- 运算符是 lists:subtract/2 的别名。这个运算符并不常用：它的作用是从左侧列表中删除右侧列表中的元素。然 而，针对右侧列表中的每一个元素，-- 运算符只会删除左侧列表中自左往右出现的第一个匹配项。因此要想完全删除指定的元素，就必须知道该元素在左侧列表中的出现次数。

这个函数的缺点在于它用的是平方复杂度的算法，针对右侧列表中的每一个元素，都要对左侧列表做一次遍历。如果元素的次序并不重要，那么更高效的做法是先排序，再调用orderset:subtract/2。

list_to_atom/1
---

动态创建原子会造成内存泄漏，除非重启节点，原子是不会被回收的，原子表的容量是有限的，一百多万项。

某些场景下使用 list_to_existing_atom/1 也许会更合适。

length/1
---

为了计算元素的个数，length(List) 必须遍历整个列表

size/1
---

与 length/1 相区分，length 仅适用于列表；size 不适用于列表，但适用于元组和二进制串。size 是常数操作，无须遍历所有数据。

size 用于元组时返回的是元素数；用于二进制串时返回的是字节数。

推荐使用 tuple_size(T) 获取元组的元素数；使用 byte_size(B) 或 bit_size(B) 获取二进制串或位串中的字节数或比特位数，对于(长度不可被8整除的)位串，byte_size(B) 会向上取整 -- 也就是说，它返回的是能容纳B中所有比特位的最小字节数。

函数调用速度
---

| 函数调用类型 | 耗时 |
| - | - |
| 本地函数：foo() | 非常快 |
| 已知的远程函数：bar:foo() | 几乎和本地函数调用一样快 |
| 未知的远程函数：Mod:Func() | 大约比本地调用慢3倍 |
| Fun函数调用：F() | 比本地调用慢2~3倍 |
| 元调用：apply(Mod, Func, Args) | 比本地调用慢6~10倍 |

设置堆的初始尺寸
---

为生存期较短而工作量较为固定的进程设置更大的初始堆，以避免垃圾回收和堆大小的调整

> erlang:spawn_opt(Fun, [{ min_heap_size, Words}])

实际上是拿内存空间换速度

休眠
---

如果有大量进程需要长期保持活跃，且其中大部分进程因等待消息而处于睡眠状态，就可以考虑让这些进程转入休眠状态。

调用 erlang:hibernate(Mode, Func, Args) 即可令进程休眠。

休眠的进程会抛弃调用栈，忘却自身在程序中的当前执行位置。有鉴于此，hibernate/3永不返回，当前正活跃的catch或try/catch表达式也会被忽略。接着，将会强制执行一次垃圾回收，精简进程的内存占用。最后，进程进入睡眠状态，直到新消息再次进入信箱。（若休眠时信箱不为空，进程将被立即唤醒。）进程被唤醒后的行为就仿佛是调用了apply(Mod,Func,Args)，不过该“调用”没有返回地址。

休眠可以精简睡眠中的进程的内存占用，释放出更多的空间容纳更多的进程。这一手法特别适用于那些监控着大量外部实体的系统。

基于proc_lib的进程，如gen_server及其他OTP行为模式，应该使用proc_lib:hibernate/3而不是erlang:hibernate/3，以确保进程醒来后周遭一切都遵照OTP库的约定再次打点妥当。

键/值存储
---

* 属性列表

    灵活但定义不够严格，一般用于处理配置列表

* 有序字典(orddict)

    一般，对于小于75个元素的数据量，有序字典（orddict）在复杂性和效率之间做到了很好的平衡，如果超过这个数据量，应该使用后面的其他键/值存储。

* 字典(dict)

    字典的读取性能较好，有折叠操作函数

* 通用平衡树(gb_trees)

    在除读取外的其他操作方面较快，没有折叠操作函数，但是有迭代操作函数，可以自己编写递归函数实现折叠；保留了所有元素的顺序，可以快速访问最大和最小元素，可以方便的按顺序遍历

* 其他

    ETS、DETS、Mnesia数据库等，主要用于多进程和并发的场景，在Erlang趣学指南25章中有所介绍，之后再补充进来。